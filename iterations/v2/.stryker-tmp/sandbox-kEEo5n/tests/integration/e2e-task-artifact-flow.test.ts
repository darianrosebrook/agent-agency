/**
 * End-to-End Test for Complete Task Flow: Submit → Route → Artifact → Observe
 *
 * @author @darianrosebrook
 */
// @ts-nocheck


import { afterEach, beforeEach, describe, expect, it } from "@jest/globals";
import * as fs from "fs";
import * as path from "path";
import { events } from "../../src/orchestrator/EventEmitter.js";
import { EventTypes } from "../../src/orchestrator/OrchestratorEvents.js";
import { ArbiterRuntime } from "../../src/orchestrator/runtime/ArbiterRuntime.js";

describe("E2E Task Flow: Submit → Route → Artifact → Observe", () => {
  const testOutputDir = path.join(__dirname, "..", "fixtures", "e2e-output");
  let runtime: ArbiterRuntime;
  let eventLog: any[] = [];
  let eventHandler: (event: any) => void;

  beforeEach(async () => {
    // Clean up any existing test output
    if (fs.existsSync(testOutputDir)) {
      fs.rmSync(testOutputDir, { recursive: true, force: true });
    }
    fs.mkdirSync(testOutputDir, { recursive: true });

    // Reset event log
    eventLog = [];

    // Listen to events for verification
    eventHandler = (event: any) => {
      console.log(`Test received event: ${event.type}`);
      eventLog.push(event);
    };

    events.on("task.completed", eventHandler);
    events.on("task.assigned", eventHandler);
    events.on("registry.ready", eventHandler);

    // Create runtime with test configuration
    runtime = new ArbiterRuntime({
      outputDir: testOutputDir,
    });

    // Start runtime (this will initialize registry)
    await runtime.start();
  }, 30000); // 30 second timeout for setup

  afterEach(async () => {
    // Stop runtime first to prevent new operations
    if (runtime) {
      await runtime.stop();
    }

    // Remove event listeners
    if (eventHandler) {
      events.off("task.completed", eventHandler);
      events.off("task.assigned", eventHandler);
      events.off("registry.ready", eventHandler);
    }

    // Clean up test output
    if (fs.existsSync(testOutputDir)) {
      fs.rmSync(testOutputDir, { recursive: true, force: true });
    }

    // Force cleanup of any remaining async operations
    await new Promise((resolve) => setTimeout(resolve, 100));
  }, 10000); // 10 second timeout for cleanup

  it("should complete full task flow from submit to artifact creation", async () => {
    // Verify registry is ready
    const initialStatus = runtime.getStatus();
    expect(initialStatus.registryReady).toBe(true);
    expect(initialStatus.running).toBe(true);

    // Submit a task that will create artifacts via script execution
    const submitResult = await runtime.submitTask({
      description: "Execute script to create test artifacts",
      task: {
        type: "script-execution",
        payload: {
          code: `
          // Create test artifacts using the sandboxed FS API
          await context.artifacts.writeFile('report.json', JSON.stringify({
            summary: 'Test execution completed',
            timestamp: new Date().toISOString(),
            framework: 'TypeScript',
            status: 'success'
          }, null, 2));

          await context.artifacts.writeFile('source.ts', 'export class TestClass {\\n  constructor() {}\\n  \\n  testMethod() {\\n    return "test";\\n  }\\n}');

          await context.artifacts.writeFile('README.md', '# Test Project\\n\\nThis is a test project generated by the artifact sandbox.');

          await context.artifacts.mkdir('tests');
          await context.artifacts.writeFile('tests/example.test.ts', 'describe(\\"Test Suite\\", () => {\\n  it(\\"should pass\\", () => {\\n    expect(true).toBe(true);\\n  });\\n});');

          context.result = 'Artifacts created successfully';
        `,
          args: [],
          timeout: 10000,
        },
        priority: 1,
        timeoutMs: 15000,
        budget: { maxFiles: 10, maxLoc: 1000 },
        attempts: 0,
        maxAttempts: 3,
        createdAt: new Date(),
        metadata: {
          framework: "TypeScript",
          taskType: "code-generation",
        },
      },
    });

    expect(submitResult.taskId).toBeDefined();
    expect(submitResult.queued).toBe(true);
    expect(submitResult.assignmentId).toBeDefined();

    // Wait for task completion
    await runtime.waitForCompletion(submitResult.taskId);

    // Verify final task status
    const taskSnapshot = runtime.getTaskSnapshot(submitResult.taskId);
    expect(taskSnapshot).toBeDefined();
    expect(taskSnapshot!.state).toBe("completed");
    expect(taskSnapshot!.outputPath).toBeDefined();
    expect(taskSnapshot!.artifacts).toBeDefined();

    // Verify artifacts were created
    const artifacts = taskSnapshot!.artifacts!;
    expect(artifacts.manifest).toBeDefined();
    expect(artifacts.rootPath).toBeDefined();
    expect(artifacts.manifest.taskId).toBe(submitResult.taskId);
    expect(artifacts.manifest.files.length).toBeGreaterThan(0);

    // Verify artifact files exist on disk
    for (const file of artifacts.manifest.files) {
      const fullPath = path.join(artifacts.rootPath, file.path);
      expect(fs.existsSync(fullPath)).toBe(true);

      // Verify file content matches manifest
      const content = fs.readFileSync(fullPath);
      expect(content.length).toBe(file.size);

      // Verify SHA256 hash
      const crypto = await import("crypto");
      const actualHash = crypto
        .createHash("sha256")
        .update(content)
        .digest("hex");
      expect(actualHash).toBe(file.sha256);
    }

    // Verify total size matches
    const totalSize = artifacts.manifest.files.reduce(
      (sum: number, f: any) => sum + f.size,
      0
    );
    expect(artifacts.manifest.totalSize).toBe(totalSize);

    // Verify manifest file exists
    const manifestPath = path.join(artifacts.rootPath, "manifest.json");
    expect(fs.existsSync(manifestPath)).toBe(true);

    const manifestContent = fs.readFileSync(manifestPath, "utf8");
    const manifestData = JSON.parse(manifestContent);
    expect(manifestData).toEqual(artifacts.manifest);

    // Verify events were emitted
    const taskCompletedEvents = eventLog.filter(
      (e) => e.type === EventTypes.TASK_COMPLETED
    );
    expect(taskCompletedEvents.length).toBeGreaterThan(0);

    const taskAssignedEvents = eventLog.filter(
      (e) => e.type === EventTypes.TASK_ASSIGNED
    );
    expect(taskAssignedEvents.length).toBeGreaterThan(0);

    // Verify registry ready event was emitted
    // Registry should already be ready from beforeEach setup
    const statusAfterTask = runtime.getStatus();
    expect(statusAfterTask.registryReady).toBe(true);

    // For script execution tasks, verify assignment to arbiter-runtime (direct execution)
    const assignedEvent = taskAssignedEvents.find(
      (e) => e.metadata?.taskId === submitResult.taskId
    );
    expect(assignedEvent).toBeDefined();
    expect(assignedEvent!.metadata.agentId).toBe("arbiter-runtime"); // Script tasks execute directly

    console.log(`✅ E2E test completed successfully:`);
    console.log(`   Task ID: ${submitResult.taskId}`);
    console.log(`   Assigned Agent: ${submitResult.assignmentId}`);
    console.log(`   Artifact Files: ${artifacts.manifest.files.length}`);
    console.log(`   Total Size: ${artifacts.manifest.totalSize} bytes`);
    console.log(`   Output Path: ${artifacts.rootPath}`);
  }, 30000); // 30 second timeout for E2E test

  it("should handle task failure gracefully", async () => {
    // Submit a task that will fail
    const submitResult = await runtime.submitTask({
      description: "Execute script that intentionally fails",
      task: {
        type: "script-execution",
        payload: {
          code: `
            // This script will intentionally fail
            throw new Error("Intentional test failure");
          `,
          args: [],
          timeout: 5000,
        },
        priority: 1,
        timeoutMs: 10000,
        budget: { maxFiles: 10, maxLoc: 1000 },
        attempts: 0,
        maxAttempts: 3,
        createdAt: new Date(),
        metadata: {
          testFailure: true,
        },
      },
    });

    // Wait for completion (should fail)
    await runtime.waitForCompletion(submitResult.taskId);

    // Verify task failed
    const taskSnapshot = runtime.getTaskSnapshot(submitResult.taskId);
    expect(taskSnapshot!.state).toBe("failed");

    // Verify failure event was emitted
    const taskFailedEvents = eventLog.filter(
      (e) => e.type === EventTypes.TASK_FAILED
    );
    expect(taskFailedEvents.length).toBeGreaterThan(0);

    // Even on failure, should have some artifacts (error logs, partial results, etc.)
    if (taskSnapshot!.artifacts) {
      const artifacts = taskSnapshot!.artifacts;
      expect(artifacts.manifest.files.length).toBeGreaterThan(0);

      // Verify artifact files exist
      for (const file of artifacts.manifest.files) {
        const fullPath = path.join(artifacts.rootPath, file.path);
        expect(fs.existsSync(fullPath)).toBe(true);
      }
    }
  }, 30000);

  it("should reject tasks when registry is not ready", async () => {
    // Stop runtime to simulate registry not ready
    await runtime.stop();

    // Create new runtime but don't start it
    const unreadyRuntime = new ArbiterRuntime({
      outputDir: testOutputDir,
    });

    // Try to submit task before starting (registry not initialized)
    await expect(
      unreadyRuntime.submitTask({
        description: "This should fail - registry not ready",
        task: {
          type: "script-execution",
          payload: {
            code: "context.result = 'test';",
            args: [],
            timeout: 5000,
          },
          priority: 1,
          timeoutMs: 10000,
          budget: { maxFiles: 10, maxLoc: 1000 },
          attempts: 0,
          maxAttempts: 3,
          createdAt: new Date(),
        },
      })
    ).rejects.toThrow("Registry not initialized");

    // Verify status shows registry not ready
    const status = unreadyRuntime.getStatus();
    expect(status.registryReady).toBe(false);
    expect(status.running).toBe(false);
  });

  it("should handle concurrent tasks correctly", async () => {
    const taskCount = 3;
    const submitPromises = [];

    // Submit multiple tasks concurrently
    for (let i = 0; i < taskCount; i++) {
      const promise = runtime.submitTask({
        description: `Concurrent task ${i + 1}: Create documentation`,
        task: {
          type: "script-execution",
          payload: {
            code: `
              // Create concurrent task artifact
              await context.artifacts.writeFile(\`task-\${${i}}.json\`, JSON.stringify({
                taskIndex: ${i},
                description: 'Concurrent task ${i}',
                timestamp: new Date().toISOString()
              }, null, 2));
              context.result = 'Task ${i} completed';
            `,
            args: [],
            timeout: 8000,
          },
          priority: 1,
          timeoutMs: 12000,
          budget: { maxFiles: 10, maxLoc: 1000 },
          attempts: 0,
          maxAttempts: 3,
          createdAt: new Date(),
          metadata: {
            concurrent: true,
            taskIndex: i,
          },
        },
      });
      submitPromises.push(promise);
    }

    const submitResults = await Promise.all(submitPromises);
    expect(submitResults).toHaveLength(taskCount);

    // Wait for all tasks to complete
    const completionPromises = submitResults.map((result) =>
      runtime.waitForCompletion(result.taskId)
    );
    await Promise.all(completionPromises);

    // Verify all tasks completed successfully
    for (const result of submitResults) {
      const snapshot = runtime.getTaskSnapshot(result.taskId);
      expect(snapshot!.state).toBe("completed");
      expect(snapshot!.artifacts).toBeDefined();

      // Verify artifacts exist
      const artifacts = snapshot!.artifacts!;
      for (const file of artifacts.manifest.files) {
        const fullPath = path.join(artifacts.rootPath, file.path);
        expect(fs.existsSync(fullPath)).toBe(true);
      }
    }

    // Verify unique agent assignments
    const assignedAgents = submitResults.map((r) => r.assignmentId);
    const uniqueAgents = new Set(assignedAgents);
    expect(uniqueAgents.size).toBeGreaterThan(0); // At least one agent was used

    console.log(`✅ Concurrent test completed:`);
    console.log(`   Tasks: ${taskCount}`);
    console.log(`   Unique Agents Used: ${uniqueAgents.size}`);
    console.log(`   Agent Assignments: ${assignedAgents.join(", ")}`);
  }, 45000); // Longer timeout for concurrent tasks

  it("should create artifacts within size and count limits", async () => {
    // Submit task that will create multiple files
    const submitResult = await runtime.submitTask({
      description: "Create multiple test artifacts",
      task: {
        type: "script-execution",
        payload: {
          code: `
          // Create multiple files within limits
          await context.artifacts.writeFile('report.json', JSON.stringify({
            summary: 'Large test report',
            data: 'x'.repeat(50000) // ~50KB
          }, null, 2));

          await context.artifacts.writeFile('config.json', JSON.stringify({
            app: 'test',
            version: '1.0.0',
            settings: { debug: true, timeout: 5000 }
          }, null, 2));

          await context.artifacts.mkdir('src');
          await context.artifacts.writeFile('src/main.ts', 'export class App {\\n  run() {\\n    console.log("Hello World");\\n  }\\n}');
          await context.artifacts.writeFile('src/utils.ts', 'export function helper() {\\n  return "helper";\\n}');

          await context.artifacts.mkdir('tests');
          await context.artifacts.writeFile('tests/app.test.ts', 'describe("App", () => {\\n  it("should work", () => {\\n    expect(true).toBe(true);\\n  });\\n});');

          await context.artifacts.writeFile('README.md', '# Test Project\\n\\nMultiple files test.');

          context.result = 'Multiple artifacts created';
        `,
          args: [],
          timeout: 10000,
        },
        priority: 1,
        timeoutMs: 15000,
        budget: { maxFiles: 10, maxLoc: 1000 },
        attempts: 0,
        maxAttempts: 3,
        createdAt: new Date(),
        metadata: {
          createMultipleFiles: true,
          expectedFileCount: 5,
        },
      },
    });

    await runtime.waitForCompletion(submitResult.taskId);

    const snapshot = runtime.getTaskSnapshot(submitResult.taskId);
    expect(snapshot!.artifacts).toBeDefined();

    const artifacts = snapshot!.artifacts!;
    const manifest = artifacts.manifest;

    // Verify reasonable limits (based on test config)
    expect(manifest.files.length).toBeLessThanOrEqual(10); // maxTotalFiles in test config
    expect(manifest.totalSize).toBeLessThanOrEqual(10 * 1024 * 1024); // Rough estimate

    // Verify all files are within individual size limits
    for (const file of manifest.files) {
      expect(file.size).toBeLessThanOrEqual(1024 * 1024); // 1MB per file in test config
      expect(file.path.length).toBeLessThanOrEqual(100); // maxPathLength in test config
    }

    console.log(`✅ Artifact limits test:`);
    console.log(`   Files Created: ${manifest.files.length}`);
    console.log(`   Total Size: ${manifest.totalSize} bytes`);
    console.log(
      `   Average File Size: ${Math.round(
        manifest.totalSize / manifest.files.length
      )} bytes`
    );
  }, 30000);

  it("should generate proper artifact metadata and manifest", async () => {
    const submitResult = await runtime.submitTask({
      description:
        "Create artifacts with various file types for metadata testing",
      task: {
        type: "script-execution",
        payload: {
          code: `
          // Create files with different types for metadata testing
          await context.artifacts.writeFile('data.json', JSON.stringify({ test: 'data' }, null, 2));
          await context.artifacts.writeFile('script.js', 'console.log("Hello from script");\\nfunction test() { return true; }');
          await context.artifacts.writeFile('markup.html', '<!DOCTYPE html><html><head><title>Test</title></head><body><h1>Test Page</h1></body></html>');
          await context.artifacts.writeFile('styles.css', 'body { font-family: Arial; }\\n.test { color: blue; }');
          await context.artifacts.writeFile('plain.txt', 'This is a plain text file.\\nIt has multiple lines.\\nAnd some content.');
          await context.artifacts.writeFile('empty.txt', '');
          context.result = 'Metadata test artifacts created';
        `,
          args: [],
          timeout: 8000,
        },
        priority: 1,
        timeoutMs: 12000,
        budget: { maxFiles: 10, maxLoc: 1000 },
        attempts: 0,
        maxAttempts: 3,
        createdAt: new Date(),
        metadata: {
          testMetadata: true,
        },
      },
    });

    await runtime.waitForCompletion(submitResult.taskId);

    const snapshot = runtime.getTaskSnapshot(submitResult.taskId);
    const artifacts = snapshot!.artifacts!;
    const manifest = artifacts.manifest;

    // Verify manifest structure
    expect(manifest.taskId).toBe(submitResult.taskId);
    expect(manifest.createdAt).toBeDefined();
    expect(Array.isArray(manifest.files)).toBe(true);
    expect(typeof manifest.totalSize).toBe("number");

    // Verify file entries have required fields
    for (const file of manifest.files) {
      expect(file.path).toBeDefined();
      expect(typeof file.size).toBe("number");
      expect(file.sha256).toBeDefined();
      expect(file.sha256.length).toBe(64); // SHA256 hex length
      expect(file.createdAt).toBeDefined();

      // Verify file exists and matches metadata
      const fullPath = path.join(artifacts.rootPath, file.path);
      expect(fs.existsSync(fullPath)).toBe(true);

      const content = fs.readFileSync(fullPath);
      expect(content.length).toBe(file.size);

      // Verify SHA256
      const crypto = await import("crypto");
      const actualHash = crypto
        .createHash("sha256")
        .update(content)
        .digest("hex");
      expect(actualHash).toBe(file.sha256);
    }

    // Verify total size calculation
    const calculatedTotal = manifest.files.reduce(
      (sum: number, f: any) => sum + f.size,
      0
    );
    expect(manifest.totalSize).toBe(calculatedTotal);

    console.log(`✅ Manifest validation:`);
    console.log(
      `   Manifest Version: ${JSON.stringify(manifest, null, 2).length} chars`
    );
    console.log(
      `   Files with SHA256: ${manifest.files.filter((f) => f.sha256).length}`
    );
    console.log(
      `   Files with MIME types: ${
        manifest.files.filter((f) => f.mimeType).length
      }`
    );
  }, 30000);
});
