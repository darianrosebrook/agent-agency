
    /// Calculate consensus score from individual verdicts
    fn calculate_consensus_score(&self, verdicts: &HashMap<String, JudgeVerdict>) -> f32 {
        if verdicts.is_empty() {
            return 0.0;
        }

        let mut total_score = 0.0;
        let mut count = 0;

        for verdict in verdicts.values() {
            let score = match verdict {
                JudgeVerdict::Pass { confidence, .. } => *confidence,
                JudgeVerdict::Fail { .. } => 0.0,
                JudgeVerdict::Uncertain { concerns, .. } => {
                    // For uncertain verdicts, use a moderate score
                    0.5
                }
            };
            total_score += score;
            count += 1;
        }

        if count > 0 {
            total_score / count as f32
        } else {
            0.0
        }
    }

    /// Determine final verdict based on consensus and evidence
    fn determine_final_verdict(
        &self,
        individual_verdicts: &HashMap<String, JudgeVerdict>,
        consensus_score: f32,
        evidence: &[EvidencePacket],
    ) -> FinalVerdict {
        if consensus_score > 0.7 {
            FinalVerdict::Accepted {
                confidence: consensus_score,
                summary: "High consensus reached among judges".to_string(),
            }
        } else if consensus_score < 0.3 {
            FinalVerdict::Rejected {
                primary_reasons: vec!["Low consensus indicates significant concerns".to_string()],
                summary: "Insufficient consensus for acceptance".to_string(),
            }
        } else {
            // Collect required changes from individual verdicts
            let mut required_changes = Vec::new();

            // Analyze Fail verdicts for violations
            for (judge_id, verdict) in individual_verdicts {
                match verdict {
                    JudgeVerdict::Fail { violations, .. } => {
                        for violation in violations {
                            let priority = match violation.severity {
                                ViolationSeverity::Critical => Priority::Critical,
                                ViolationSeverity::Major => Priority::High,
                                ViolationSeverity::Minor => Priority::Medium,
                                ViolationSeverity::Warning => Priority::Low,
                            };

                            required_changes.push(RequiredChange {
                                priority,
                                description: format!("Address violation: {}", violation.description),
                                rationale: format!("Judge '{}' identified critical issue: {}", judge_id, violation.rule),
                                estimated_effort: violation.suggestion.map(|s| format!("Suggested fix: {}", s)),
                            });
                        }
                    }
                    JudgeVerdict::Uncertain { concerns, recommendation, .. } => {
                        if matches!(recommendation, Recommendation::Modify) {
                            for concern in concerns {
                                let priority = match concern.impact.as_str() {
                                    "high" | "critical" => Priority::High,
                                    "medium" => Priority::Medium,
                                    _ => Priority::Low,
                                };

                                required_changes.push(RequiredChange {
                                    priority,
                                    description: format!("Address concern: {}", concern.description),
                                    rationale: format!("Judge '{}' concern in area '{}': {}", judge_id, concern.area, concern.impact),
                                    estimated_effort: concern.mitigation.clone(),
                                });
                            }
                        }
                    }
                    _ => {} // Pass verdicts don't contribute to required changes
                }
            }

            // Deduplicate and prioritize changes
            required_changes.sort_by(|a, b| a.priority.cmp(&b.priority));
            required_changes.dedup_by(|a, b| a.description == b.description);

            FinalVerdict::RequiresModification {
                required_changes,
                summary: format!("Mixed consensus requires {} modifications", required_changes.len()),
            }
        }
    }

    /// Orchestrate debate rounds
    async fn orchestrate_debate(
        &self,
        individual_verdicts: &HashMap<String, JudgeVerdict>,
        task_spec: &TaskSpec,
    ) -> Result<u32> {
