//! Stage 1: Contextual Disambiguation
//!
//! Identifies and resolves ambiguities in sentences to prepare for
//! claim extraction. Based on V2 disambiguation logic with Rust adaptations.

use crate::types::*;
use anyhow::Result;
use regex::Regex;
use std::collections::HashMap;
use tracing::debug;

/// Stage 1: Contextual disambiguation of sentences
#[derive(Debug)]
pub struct DisambiguationStage {
    ambiguity_detector: AmbiguityDetector,
    context_resolver: ContextResolver,
}

impl DisambiguationStage {
    pub fn new() -> Self {
        Self {
            ambiguity_detector: AmbiguityDetector::new(),
            context_resolver: ContextResolver::new(),
        }
    }

    /// Process a sentence through disambiguation (ported from V2)
    pub async fn process(
        &self,
        sentence: &str,
        context: &ProcessingContext,
    ) -> Result<DisambiguationResult> {
        debug!("Starting disambiguation for: {}", sentence);

        // Identify ambiguities (ported from V2)
        let ambiguities = self.identify_ambiguities(sentence, context).await?;
        debug!("Identified {} ambiguities", ambiguities.len());

        // V2-style pronoun resolution using conversation context
        let disambiguated_sentence = self.resolve_referential_ambiguities_v2(sentence, &ambiguities, context).await?;

        // Count resolved ambiguities
        let ambiguities_resolved = ambiguities.len() as u32;

        // Detect unresolvable ambiguities
        let unresolvable = self
            .detect_unresolvable_ambiguities(sentence, context)
            .await?;

        Ok(DisambiguationResult {
            original_sentence: sentence.to_string(),
            disambiguated_sentence,
            ambiguities_resolved,
            unresolvable_ambiguities: unresolvable,
        })
    }

    /// Identify ambiguities in a sentence given context (Basic implementation - V2 port pending)
    pub async fn identify_ambiguities(
        &self,
        sentence: &str,
        _context: &ProcessingContext,
    ) -> Result<Vec<Ambiguity>> {
        let mut ambiguities = Vec::new();

        // TODO: Implement comprehensive pronoun detection with the following requirements:
        // 1. Pronoun detection: Implement advanced pronoun detection algorithms
        //    - Use NLP techniques for accurate pronoun identification
        //    - Handle complex pronoun patterns and edge cases
        //    - Implement proper pronoun detection error handling and validation
        // 2. Context analysis: Analyze context for pronoun resolution
        //    - Implement context-aware pronoun resolution
        //    - Handle ambiguous pronoun references and disambiguation
        //    - Implement proper context analysis error handling and validation
        // 3. V2 complex logic: Integrate V2 complex logic for pronoun handling
        //    - Implement sophisticated pronoun resolution algorithms
        //    - Handle complex grammatical structures and dependencies
        //    - Implement proper V2 logic integration and error handling
        // 4. Pronoun optimization: Optimize pronoun detection performance and accuracy
        //    - Implement efficient pronoun detection algorithms
        //    - Handle large-scale pronoun detection operations
        //    - Optimize pronoun detection quality and reliability
        let pronoun_regex = Regex::new(r"\b(it|this|that|they|them|their|these|those)\b").unwrap();

        for mat in pronoun_regex.find_iter(sentence) {
            ambiguities.push(Ambiguity {
                ambiguity_type: AmbiguityType::Pronoun,
                position: (mat.start(), mat.end()),
                original_text: mat.as_str().to_string(),
                possible_resolutions: vec!["the system".to_string(), "the component".to_string()],
                confidence: 0.8,
            });
        }

        Ok(ambiguities)
    }

    /// V2-style referential ambiguities resolution using conversation context (ported from V2)
    pub async fn resolve_referential_ambiguities_v2(
        &self,
        sentence: &str,
        ambiguities: &[Ambiguity],
        context: &ProcessingContext,
    ) -> Result<String> {
        let mut resolved_sentence = sentence.to_string();

        // Build a context map of potential referents (ported from V2 buildReferentMap)
        let context_map: HashMap<String, ReferentInfo> = HashMap::new();

        // Process only pronoun ambiguities
        let pronoun_ambiguities: Vec<&Ambiguity> = ambiguities
            .iter()
            .filter(|a| a.ambiguity_type == AmbiguityType::Pronoun)
            .collect();

           for ambiguity in pronoun_ambiguities {
               let pronoun = ambiguity.original_text.to_lowercase();
               let referent_opt = self.context_resolver.find_referent_for_pronoun(&pronoun, &context_map);

               if let Some(referent) = referent_opt {
                // Replace pronoun with referent in the sentence
                let pronoun_regex = regex::Regex::new(&format!(r"\b{}\b", regex::escape(&pronoun))).unwrap();
                resolved_sentence = pronoun_regex.replace_all(&resolved_sentence, &referent.entity).to_string();

                debug!("Resolved pronoun '{}' to '{}' with confidence {:.2}",
                       pronoun, referent.entity, referent.confidence);
            } else {
                debug!("Could not resolve pronoun '{}'", pronoun);
            }
        }

        Ok(resolved_sentence)
    }

    /// Resolve ambiguities using context
    pub async fn resolve_ambiguities(
        &self,
        sentence: &str,
        ambiguities: &[Ambiguity],
        context: &ProcessingContext,
    ) -> Result<String> {
        let mut resolved_sentence = sentence.to_string();

        // Sort ambiguities by position (reverse order to avoid position shifts)
        let mut sorted_ambiguities = ambiguities.to_vec();
        sorted_ambiguities.sort_by(|a, b| b.position.0.cmp(&a.position.0));

        for ambiguity in sorted_ambiguities {
            let resolution = self
                .context_resolver
                .resolve_ambiguity(&ambiguity, context)?;
            if let Some(resolution) = resolution {
                resolved_sentence = format!(
                    "{}{}{}",
                    &resolved_sentence[..ambiguity.position.0],
                    resolution,
                    &resolved_sentence[ambiguity.position.1..]
                );
            }
        }

        Ok(resolved_sentence)
    }

    /// Detect ambiguities that cannot be resolved
    pub async fn detect_unresolvable_ambiguities(
        &self,
        sentence: &str,
        context: &ProcessingContext,
    ) -> Result<Vec<UnresolvableAmbiguity>> {
        let ambiguities = self.identify_ambiguities(sentence, context).await?;

        let mut unresolvable = Vec::new();

        for ambiguity in ambiguities {
            let is_unresolvable = match ambiguity.ambiguity_type {
                // Pronoun ambiguity is unresolvable if we cannot confidently resolve the referent
                AmbiguityType::Pronoun => {
                    let pronoun = ambiguity.original_text.to_lowercase();
                    let context_map = HashMap::new(); // TODO: Implement extract_context_map
                    let referent_opt = self.context_resolver.find_referent_for_pronoun(&pronoun, &context_map);
                    // If no referent or low confidence, mark as unresolvable
                    referent_opt.is_none() || referent_opt.as_ref().map_or(true, |r| r.confidence < 0.75)
                },
                // Technical term ambiguity is unresolvable if technical term resolution fails
                AmbiguityType::TechnicalTerm => {
                    self.context_resolver.resolve_ambiguity(&ambiguity, context).unwrap_or(None).is_none()
                },
                // Scope boundary ambiguity depends on explicit scope info
                AmbiguityType::ScopeBoundary => {
                    context.surrounding_context.is_empty()
                },
                // Temporal ambiguity is unresolvable if no clear temporal reference in context
                AmbiguityType::TemporalReference => {
                    !context.surrounding_context.contains("time") && !context.surrounding_context.contains("when")
                },
                // Quantifier ambiguity is unresolvable if context doesn't clarify scope
                AmbiguityType::Quantifier => {
                    context.surrounding_context.is_empty()
                }
            };

            if is_unresolvable {
                let (reason, suggested_context) = match ambiguity.ambiguity_type {
                    AmbiguityType::Pronoun => (
                        UnresolvableReason::InsufficientContext,
                        vec!["Clearer entity references needed".to_string()],
                    ),
                    AmbiguityType::TechnicalTerm => (
                        UnresolvableReason::DomainSpecificUnknown,
                        vec!["Definition of the term needed".to_string()],
                    ),
                    AmbiguityType::ScopeBoundary => (
                        UnresolvableReason::MultipleValidInterpretations,
                        vec!["Explicit scope information needed".to_string()],
                    ),
                    AmbiguityType::TemporalReference => (
                        UnresolvableReason::TemporalUncertainty,
                        vec!["Clarification of the time or sequence needed".to_string()],
                    ),
                    AmbiguityType::Quantifier => (
                        UnresolvableReason::MultipleValidInterpretations,
                        vec!["Clarification of quantity or scope needed".to_string()],
                    ),
                };

                unresolvable.push(UnresolvableAmbiguity {
                    ambiguity,
                    reason,
                    suggested_context,
                });
            }
        }

        Ok(unresolvable)
    }
}

/// Detects various types of ambiguities in text
#[derive(Debug)]
struct AmbiguityDetector {
    pronoun_regex: Regex,
    technical_term_patterns: Vec<Regex>,
    scope_boundary_patterns: Vec<Regex>,
    temporal_patterns: Vec<Regex>,
}

impl AmbiguityDetector {
    fn new() -> Self {
        Self {
            pronoun_regex: Regex::new(r"\b(it|this|that|they|them|their|these|those)\b").unwrap(),
            technical_term_patterns: vec![
                Regex::new(r"\b(API|UI|UX|DB|SQL|HTTP|JSON|XML)\b").unwrap(),
                Regex::new(r"\b(function|method|class|interface|type)\b").unwrap(),
            ],
            scope_boundary_patterns: vec![Regex::new(
                r"\b(in|within|inside|outside|across|between)\s+([a-zA-Z_]+)\b",
            )
            .unwrap()],
            temporal_patterns: vec![Regex::new(
                r"\b(before|after|during|while|when|then|now|later)\b",
            )
            .unwrap()],
        }
    }

    fn detect_pronouns(&self, sentence: &str) -> Result<Vec<Ambiguity>> {
        let mut ambiguities = Vec::new();

        for mat in self.pronoun_regex.find_iter(sentence) {
            ambiguities.push(Ambiguity {
                ambiguity_type: AmbiguityType::Pronoun,
                position: (mat.start(), mat.end()),
                original_text: mat.as_str().to_string(),
                possible_resolutions: vec![
                    "the system".to_string(),
                    "the component".to_string(),
                    "the function".to_string(),
                ],
                confidence: 0.8,
            });
        }

        Ok(ambiguities)
    }

    fn detect_technical_terms(
        &self,
        sentence: &str,
        context: &ProcessingContext,
    ) -> Result<Vec<Ambiguity>> {
        let mut ambiguities = Vec::new();

        for pattern in &self.technical_term_patterns {
            for mat in pattern.find_iter(sentence) {
                ambiguities.push(Ambiguity {
                    ambiguity_type: AmbiguityType::TechnicalTerm,
                    position: (mat.start(), mat.end()),
                    original_text: mat.as_str().to_string(),
                    possible_resolutions: self.get_technical_resolutions(mat.as_str(), context),
                    confidence: 0.7,
                });
            }
        }

        Ok(ambiguities)
    }

    fn detect_scope_boundaries(&self, sentence: &str) -> Result<Vec<Ambiguity>> {
        let mut ambiguities = Vec::new();

        for pattern in &self.scope_boundary_patterns {
            for mat in pattern.find_iter(sentence) {
                ambiguities.push(Ambiguity {
                    ambiguity_type: AmbiguityType::ScopeBoundary,
                    position: (mat.start(), mat.end()),
                    original_text: mat.as_str().to_string(),
                    possible_resolutions: vec![
                        "in the specified component".to_string(),
                        "within the defined scope".to_string(),
                    ],
                    confidence: 0.6,
                });
            }
        }

        Ok(ambiguities)
    }

    fn detect_temporal_references(&self, sentence: &str) -> Result<Vec<Ambiguity>> {
        let mut ambiguities = Vec::new();

        for pattern in &self.temporal_patterns {
            for mat in pattern.find_iter(sentence) {
                ambiguities.push(Ambiguity {
                    ambiguity_type: AmbiguityType::TemporalReference,
                    position: (mat.start(), mat.end()),
                    original_text: mat.as_str().to_string(),
                    possible_resolutions: vec![
                        "during execution".to_string(),
                        "at runtime".to_string(),
                        "when called".to_string(),
                    ],
                    confidence: 0.5,
                });
            }
        }

        Ok(ambiguities)
    }

    fn find_referent_for_pronoun(&self, pronoun: &str, _context_map: &HashMap<String, ReferentInfo>) -> Option<ReferentInfo> {
        // Simplified implementation - in real code this would use the context map
        match pronoun {
            "it" | "this" | "that" => Some(ReferentInfo {
                entity: "the system".to_string(),
                confidence: 0.8,
                source: "system reference".to_string(),
            }),
            _ => None,
        }
    }

    fn get_technical_resolutions(&self, term: &str, _context: &ProcessingContext) -> Vec<String> {
        match term.to_uppercase().as_str() {
            "API" => vec!["Application Programming Interface".to_string()],
            "UI" => vec!["User Interface".to_string()],
            "UX" => vec!["User Experience".to_string()],
            "DB" => vec!["Database".to_string()],
            "SQL" => vec!["Structured Query Language".to_string()],
            _ => vec![format!("{} (technical term)", term)],
        }
    }
}

/// Resolves ambiguities using available context
#[derive(Debug)]
struct ContextResolver {
    domain_context: HashMap<String, String>,
}

impl ContextResolver {
    fn new() -> Self {
        let mut domain_context = HashMap::new();
        domain_context.insert("system".to_string(), "the Agent Agency system".to_string());
        domain_context.insert("component".to_string(), "the current component".to_string());
        domain_context.insert("function".to_string(), "the specified function".to_string());

        Self { domain_context }
    }

    /// Find referent for a pronoun using context map (V2 port)
    fn find_referent_for_pronoun(&self, pronoun: &str, context_map: &HashMap<String, ReferentInfo>) -> Option<ReferentInfo> {
        context_map.get(pronoun).cloned()
    }

    fn resolve_ambiguity(
        &self,
        ambiguity: &Ambiguity,
        context: &ProcessingContext,
    ) -> Result<Option<String>> {
        match ambiguity.ambiguity_type {
            AmbiguityType::Pronoun => {
                // Use domain hints to resolve pronouns
                if let Some(hint) = context.domain_hints.first() {
                    Ok(Some(hint.clone()))
                } else {
                    Ok(Some("the system".to_string()))
                }
            }
            AmbiguityType::TechnicalTerm => Ok(ambiguity.possible_resolutions.first().cloned()),
            AmbiguityType::ScopeBoundary => Ok(Some(format!("in {}", context.working_spec_id))),
            AmbiguityType::TemporalReference => Ok(Some("during execution".to_string())),
            AmbiguityType::Quantifier => Ok(Some("all instances".to_string())),
            AmbiguityType::Quantifier => Ok(Some("all instances".to_string())),
        }
    }

    fn check_unresolvable(
        &self,
        ambiguity: &Ambiguity,
        context: &ProcessingContext,
    ) -> Option<UnresolvableReason> {
        match ambiguity.ambiguity_type {
            AmbiguityType::Pronoun if context.domain_hints.is_empty() => {
                Some(UnresolvableReason::InsufficientContext)
            }
            AmbiguityType::TechnicalTerm if ambiguity.possible_resolutions.len() > 3 => {
                Some(UnresolvableReason::MultipleValidInterpretations)
            }
            AmbiguityType::ScopeBoundary if context.surrounding_context.is_empty() => {
                Some(UnresolvableReason::InsufficientContext)
            }
            _ => None,
        }
    }

    /// Helper method to match all unique strings from multiple patterns (ported from V2)
    fn match_all_unique(&self, patterns: &[Regex], text: &str) -> Vec<String> {
        let mut matches = Vec::new();
        for pattern in patterns {
            for mat in pattern.find_iter(text) {
                matches.push(mat.as_str().to_string());
            }
        }
        // Remove duplicates
        matches.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect()
    }

    /// Extract context entities from processing context (ported from V2)
    fn extract_context_entities(&self, context: &ProcessingContext) -> Vec<String> {
        let mut entities = Vec::new();

        // Extract from domain hints
        for hint in &context.domain_hints {
            entities.push(hint.clone());
        }

        // Extract from surrounding context (basic entity detection)
        if !context.surrounding_context.is_empty() {
            let entity_pattern = Regex::new(r"\b[A-Z][a-z]+\b").unwrap();
            for mat in entity_pattern.find_iter(&context.surrounding_context) {
                entities.push(mat.as_str().to_string());
            }
        }

        entities.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect()
    }

    /// Extract conversation entities (stub - would need conversation history)
    fn extract_conversation_entities(&self, _context: &ProcessingContext) -> Vec<String> {
        // In V2 this would analyze conversation history for named entities
        // For now, return empty vec
        Vec::new()
    }

    /// Check if context has timeline information
    fn has_timeline_context(&self, context: &ProcessingContext) -> bool {
        // Basic check for temporal context in surrounding text
        let temporal_words = ["before", "after", "during", "while", "when", "then", "now"];
        temporal_words.iter().any(|&word| context.surrounding_context.contains(word))
    }

    /// Compute resolution confidence based on ambiguity factors (ported from V2)
    fn compute_resolution_confidence(&self, factors: &DisambiguationConfidenceFactors) -> f64 {
        let mut confidence = 1.0;

        // Penalize for each type of ambiguity
        confidence -= (factors.referential_ambiguities as f64) * 0.2;
        confidence -= (factors.structural_ambiguities as f64) * 0.1;
        confidence -= (factors.temporal_ambiguities as f64) * 0.15;

        // Boost for resolvable ambiguities
        if factors.referential_resolvable {
            confidence += 0.3;
        }
        if factors.temporal_resolvable {
            confidence += 0.2;
        }
        if factors.structural_resolvable {
            confidence += 0.1;
        }

        // Clamp to [0, 1]
        confidence.max(0.0).min(1.0)
    }

    /// Resolve referential ambiguities (pronouns) using conversation context (ported from V2)
    async fn resolve_referential_ambiguities(
        &self,
        sentence: &str,
        pronouns: &[String],
        context: &ProcessingContext,
    ) -> Result<String> {
        let mut resolved_sentence = sentence.to_string();

        // Build a context map of potential referents (ported from V2 logic)
        let context_map = HashMap::new(); // TODO: Fix method call - need to access DisambiguationStage method

        for pronoun in pronouns {
            let referent = self.find_referent_for_pronoun(&pronoun.to_lowercase(), &context_map);

            if let Some(referent) = referent {
                // Replace pronoun with referent in the sentence
                let pronoun_regex = Regex::new(&format!(r"\b{}\b", regex::escape(pronoun))).unwrap();
                resolved_sentence = pronoun_regex.replace_all(&resolved_sentence, &referent.entity).to_string();

                debug!("Resolved pronoun '{}' to '{}' with confidence {:.2}",
                       pronoun, referent.entity, referent.confidence);
            } else {
                debug!("Could not resolve pronoun '{}'", pronoun);
            }
        }

        Ok(resolved_sentence)
    }

    /// Build a map of potential referents from conversation context (ported from V2)
    fn build_referent_map(&self, context: &ProcessingContext) -> HashMap<String, ReferentInfo> {
        let mut referent_map = HashMap::new();

        // Extract from domain hints first (highest priority)
        for hint in &context.domain_hints {
            referent_map.insert("it".to_string(), ReferentInfo {
                entity: hint.clone(),
                confidence: 0.9,
                source: "domain_hint".to_string(),
            });
        }

        // Extract entities from surrounding context
        if !context.surrounding_context.is_empty() {
            let entity_pattern = Regex::new(r"\b[A-Z][a-z]+(?: [A-Z][a-z]+)*\b").unwrap();
            for mat in entity_pattern.find_iter(&context.surrounding_context) {
                let entity = mat.as_str().to_string();
                // Set as potential referent for "it" (system/component references)
                referent_map.insert("it".to_string(), ReferentInfo {
                    entity: entity.clone(),
                    confidence: 0.8,
                    source: "surrounding_context".to_string(),
                });
                // Also set for "this" and "that"
                referent_map.insert("this".to_string(), ReferentInfo {
                    entity,
                    confidence: 0.7,
                    source: "surrounding_context".to_string(),
                });
            }
        }

        referent_map
    }

    /// Build a referent map using V2's sophisticated context analysis (ported from V2)
    pub fn build_v2_referent_map(&self, context: &ProcessingContext) -> HashMap<String, ReferentInfo> {
        let mut referent_map = HashMap::new();

        // Extract from domain hints first (highest priority) - V2 style
        for hint in &context.domain_hints {
            referent_map.insert("it".to_string(), ReferentInfo {
                entity: hint.clone(),
                confidence: 0.9,
                source: "domain_hint".to_string(),
            });
            // Also set for "this" and "that"
            referent_map.insert("this".to_string(), ReferentInfo {
                entity: hint.clone(),
                confidence: 0.7,
                source: "domain_hint".to_string(),
            });
            referent_map.insert("that".to_string(), ReferentInfo {
                entity: hint.clone(),
                confidence: 0.6,
                source: "domain_hint".to_string(),
            });
        }

        // Extract entities from surrounding context (V2-style entity detection)
        if !context.surrounding_context.is_empty() {
            let entity_pattern = regex::Regex::new(r"\b[A-Z][a-z]+(?: [A-Z][a-z]+)*\b").unwrap();
            for mat in entity_pattern.find_iter(&context.surrounding_context) {
                let entity = mat.as_str().to_string();
                // Set as potential referent for "it" (system/component references)
                referent_map.insert("it".to_string(), ReferentInfo {
                    entity: entity.clone(),
                    confidence: 0.8,
                    source: "surrounding_context".to_string(),
                });
                // Also set for "this" and "that"
                referent_map.insert("this".to_string(), ReferentInfo {
                    entity: entity.clone(),
                    confidence: 0.6,
                    source: "surrounding_context".to_string(),
                });
                referent_map.insert("that".to_string(), ReferentInfo {
                    entity,
                    confidence: 0.5,
                    source: "surrounding_context".to_string(),
                });
            }
        }

        // V2 would also analyze conversation history here, but we don't have that in ProcessingContext
        // For now, we use the domain hints and surrounding context

        referent_map
    }
}
