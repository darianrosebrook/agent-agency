---
description: Comprehensive testing standards and verification requirements
globs:
alwaysApply: true
---

# Testing Standards & Verification Requirements

## Testing Pyramid Requirements

### Unit Tests (Foundation Layer)

- **Coverage Thresholds**: 80% line coverage, 90% branch coverage minimum
- **Test Isolation**: Each test completely independent, no shared state
- **Mock Strategy**: Mock external dependencies, test business logic in isolation
- **Naming Convention**: `describe('ComponentName', () => { it('should do something', () => {}) })`
- **Assertion Style**: Use descriptive assertions, avoid generic `toBe(true)`

### Integration Tests (Middle Layer)

- **Database Integration**: Real database connections, not mocked
- **External APIs**: Test actual HTTP calls with proper error handling
- **Component Communication**: Test inter-component contracts
- **Setup/Teardown**: Proper database seeding and cleanup
- **Async Handling**: All async operations properly awaited and tested

### End-to-End Tests (Top Layer)

- **Full User Journeys**: Complete workflows from start to finish
- **Real Browsers**: Use actual browser automation, not mocked DOM
- **Data Persistence**: Verify data survives application restarts
- **Performance Baselines**: Include timing assertions where relevant

## Test Quality Standards

### Test Structure Requirements

```typescript
describe("ComponentName", () => {
  describe("when condition A", () => {
    it("should behave correctly", () => {
      // Given: Setup preconditions
      // When: Execute the action
      // Then: Verify the outcome
    });
  });
});
```

### Edge Case Coverage

- **Null/Undefined**: Test with null, undefined, empty arrays, empty objects
- **Boundary Values**: Test minimums, maximums, and edge boundaries
- **Error Conditions**: Test all error paths and exception handling
- **Concurrency**: Test race conditions and concurrent access
- **Resource Limits**: Test memory limits, timeouts, rate limits

### Test Data Management

- **Realistic Fixtures**: Use representative data, not just minimal examples
- **Factory Pattern**: Create test data factories for consistent object creation
- **Cleanup Strategy**: Ensure tests don't leave persistent state
- **Isolation**: Tests must not interfere with each other

## Verification Requirements

### Pre-Commit Verification

- [ ] All unit tests pass (`npm test`)
- [ ] No tests skipped in production code
- [ ] Coverage thresholds met
- [ ] No console errors or warnings in tests
- [ ] Database tests use real connections

### Integration Verification

- [ ] Database schema matches migrations
- [ ] External API contracts validated
- [ ] Authentication/authorization tested
- [ ] Error handling verified end-to-end

### Performance Verification

- [ ] Response times within documented SLAs
- [ ] Memory usage within limits
- [ ] Database query performance acceptable
- [ ] Concurrent user load handled

## Test Infrastructure Standards

### Testing Tools & Frameworks

- **Test Runner**: Jest, Vitest, or equivalent with parallel execution
- **Assertion Library**: Built-in assertions with descriptive matchers
- **Mocking**: Comprehensive mocking for external dependencies
- **Coverage**: Istanbul/NYC for coverage reporting
- **CI Integration**: Automated test execution in CI pipeline

### Database Testing

- **Test Database**: Separate database instance for tests
- **Schema Sync**: Automatic schema setup/teardown
- **Data Seeding**: Deterministic test data seeding
- **Transaction Rollback**: Tests wrapped in transactions for cleanup

### CI/CD Testing

- **Parallel Execution**: Tests run in parallel for speed
- **Flaky Test Detection**: Automatic retry for known flaky tests
- **Coverage Reporting**: Coverage reports uploaded to CI
- **Test Result Storage**: Historical test results tracked

## Testing Anti-Patterns (Forbidden)

### ❌ Mocking Core Business Logic

```typescript
// DON'T: Mock the function you're supposed to test
jest.mock("./businessLogic", () => ({
  calculateTotal: jest.fn(() => 100),
}));

test("calculateTotal", () => {
  expect(calculateTotal()).toBe(100); // Tests the mock, not the logic
});
```

### ❌ Testing Implementation Details

```typescript
// DON'T: Test private methods or internal state
test("internal counter increments", () => {
  component.privateCounter = 5; // Accessing private state
  expect(component.privateCounter).toBe(5);
});
```

### ❌ Inadequate Error Testing

```typescript
// DON'T: Generic error testing
test("throws error", () => {
  expect(() => riskyOperation()).toThrow(); // Too vague
});
```

### ❌ No Cleanup in Integration Tests

```typescript
// DON'T: Leave test data behind
test("creates user", async () => {
  await createUser({ name: "test" });
  // No cleanup - data persists
});
```

## Testing Best Practices

### ✅ Proper Error Testing

```typescript
test("throws specific error for invalid input", () => {
  expect(() => validateEmail("invalid")).toThrow(ValidationError);
  expect(() => validateEmail("invalid")).toThrow("Invalid email format");
});
```

### ✅ Realistic Test Data

```typescript
const realisticUser = {
  id: "user-123",
  email: "user@example.com",
  name: "John Doe",
  createdAt: new Date("2024-01-01"),
  preferences: { theme: "dark", notifications: true },
};
```

### ✅ Proper Async Testing

```typescript
test("resolves with correct data", async () => {
  const result = await fetchUserData("user-123");
  expect(result).toEqual(expectedUserData);
});
```

### ✅ Database Test Cleanup

```typescript
describe("UserService", () => {
  let dbClient;

  beforeEach(async () => {
    dbClient = await createTestDbConnection();
    await seedTestData(dbClient);
  });

  afterEach(async () => {
    await cleanupTestData(dbClient);
    await dbClient.end();
  });
});
```

## Test Documentation Requirements

### Test Comments for Complex Logic

```typescript
test("calculates compound interest with monthly compounding", () => {
  // Formula: A = P(1 + r/n)^(nt)
  // Where: A = final amount, P = principal, r = rate, n = compounding frequency, t = time
  const principal = 1000;
  const rate = 0.05; // 5%
  const compoundingFrequency = 12; // monthly
  const timeInYears = 2;

  const result = calculateCompoundInterest(
    principal,
    rate,
    compoundingFrequency,
    timeInYears
  );
  const expected = 1104.54; // Pre-calculated expected value

  expect(result).toBeCloseTo(expected, 2);
});
```

### Test Coverage Comments

```typescript
// Test Coverage:
// ✅ Happy path: valid input -> correct output
// ✅ Edge case: zero principal -> zero result
// ✅ Edge case: negative rate -> throws error
// ✅ Error case: invalid compounding frequency -> throws error
// ✅ Boundary: very large numbers -> handles precision
```

## Performance Testing Standards

### Response Time Assertions

```typescript
test("responds within SLA", async () => {
  const startTime = Date.now();
  const result = await expensiveOperation();
  const duration = Date.now() - startTime;

  expect(duration).toBeLessThan(5000); // 5 second SLA
  expect(result).toBeDefined();
});
```

### Load Testing Guidelines

- Test with realistic concurrent users
- Include warm-up periods
- Measure 95th percentile response times
- Test memory usage under load
- Verify graceful degradation

## Mutation Testing Standards

### Mutation Operators to Cover

- **Arithmetic Operators**: `+`, `-`, `*`, `/`, `%`
- **Logical Operators**: `&&`, `||`, `!`
- **Comparison Operators**: `==`, `!=`, `<`, `>`, `<=`, `>=`
- **Conditional Boundaries**: `if` conditions, ternary operators
- **Return Statements**: Missing/incorrect returns
- **Variable Assignments**: Wrong variable assignments

### Mutation Score Targets

- **Critical Components**: 80%+ mutation score
- **Business Logic**: 70%+ mutation score
- **Utilities**: 60%+ mutation score
- **UI Components**: 50%+ mutation score (may be lower due to test complexity)

## Accessibility Testing (Web Components)

### Screen Reader Testing

```typescript
test("is accessible to screen readers", () => {
  render(<Button>Click me</Button>);

  // Test ARIA labels
  expect(screen.getByRole("button")).toHaveAttribute("aria-label", "Click me");

  // Test keyboard navigation
  userEvent.tab();
  expect(screen.getByRole("button")).toHaveFocus();
});
```

### Color Contrast Testing

```typescript
test("meets color contrast requirements", () => {
  render(<Text variant="error">Error message</Text>);

  const element = screen.getByText("Error message");
  const styles = window.getComputedStyle(element);

  // Verify contrast ratio programmatically
  expect(
    getContrastRatio(styles.color, styles.backgroundColor)
  ).toBeGreaterThan(4.5);
});
```