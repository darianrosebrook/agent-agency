name: Deploy Agent Agency V3

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Build orchestrator for testing
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deploy/docker/Dockerfile.orchestrator
        push: false
        tags: agent-agency/orchestrator:test
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

    - name: Build council for testing
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deploy/docker/Dockerfile.council
        push: false
        tags: agent-agency/council:test
        cache-from: type=local,src=/tmp/.buildx-cache

    # Move cache to avoid cache bloat
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  security-scan:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-push:
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for orchestrator
      id: meta-orchestrator
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-orchestrator
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push orchestrator
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deploy/docker/Dockerfile.orchestrator
        push: true
        tags: ${{ steps.meta-orchestrator.outputs.tags }}
        labels: ${{ steps.meta-orchestrator.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Extract metadata for council
      id: meta-council
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-council
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push council
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deploy/docker/Dockerfile.council
        push: true
        tags: ${{ steps.meta-council.outputs.tags }}
        labels: ${{ steps.meta-council.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Update kubeconfig for staging
      run: |
        aws eks update-kubeconfig --region us-east-1 --name agent-agency-staging

    - name: Deploy to staging
      run: |
        cd deploy/kubernetes/aws
        kustomize edit set image agent-agency/orchestrator=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-orchestrator:develop
        kustomize edit set image agent-agency/council=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-council:develop
        kubectl apply -k overlays/staging/

    - name: Run smoke tests
      run: |
        # Wait for rollout
        kubectl rollout status deployment/agent-agency-orchestrator -n agent-agency-staging --timeout=300s
        kubectl rollout status deployment/agent-agency-council -n agent-agency-staging --timeout=300s

        # Run health checks
        kubectl run smoke-test --image=curlimages/curl --rm -i --restart=Never -- curl -f http://agent-agency-orchestrator:8080/health
        kubectl run smoke-test --image=curlimages/curl --rm -i --restart=Never -- curl -f http://agent-agency-council:8081/health

  deploy-production:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Update kubeconfig for production
      run: |
        aws eks update-kubeconfig --region us-east-1 --name agent-agency-production

    - name: Deploy to production (blue-green)
      run: |
        # Get current active deployment
        CURRENT=$(kubectl get svc agent-agency-api -o jsonpath='{.spec.selector.version}' -n agent-agency-prod)

        if [ "$CURRENT" = "blue" ]; then
          TARGET="green"
        else
          TARGET="blue"
        fi

        echo "Deploying to $TARGET environment"

        # Update images for target environment
        cd deploy/kubernetes/aws
        kustomize edit set image agent-agency/orchestrator=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-orchestrator:latest
        kustomize edit set image agent-agency/council=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-council:latest

        # Deploy to target environment
        kubectl apply -k overlays/production-$TARGET/

        # Wait for rollout
        kubectl rollout status deployment/agent-agency-orchestrator-$TARGET -n agent-agency-prod --timeout=600s
        kubectl rollout status deployment/agent-agency-council-$TARGET -n agent-agency-prod --timeout=600s

    - name: Switch traffic (zero-downtime)
      run: |
        # Switch service to new deployment
        kubectl patch svc agent-agency-api -n agent-agency-prod --type='json' -p='[{"op": "replace", "path": "/spec/selector/version", "value": "'$TARGET'"}]'

        # Wait for traffic to switch
        sleep 30

    - name: Run production tests
      run: |
        # Run comprehensive health checks
        kubectl run prod-test --image=curlimages/curl --rm -i --restart=Never -- curl -f https://api.agent-agency.yourdomain.com/health

        # Run load test (optional)
        kubectl run load-test --image=fortio/fortio:latest --rm -i --restart=Never -- fortio load -qps 100 -t 60s https://api.agent-agency.yourdomain.com/api/tasks

    - name: Cleanup old deployment
      run: |
        # Keep old deployment for rollback capability
        echo "Old deployment kept for rollback. Manual cleanup required after verification."

  rollback:
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    needs: deploy-production
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Rollback production
      run: |
        aws eks update-kubeconfig --region us-east-1 --name agent-agency-production

        # Switch back to previous deployment
        PREVIOUS=$(kubectl get svc agent-agency-api -o jsonpath='{.spec.selector.version}' -n agent-agency-prod)

        if [ "$PREVIOUS" = "blue" ]; then
          ROLLBACK_TARGET="green"
        else
          ROLLBACK_TARGET="blue"
        fi

        echo "Rolling back to $ROLLBACK_TARGET"
        kubectl patch svc agent-agency-api -n agent-agency-prod --type='json' -p='[{"op": "replace", "path": "/spec/selector/version", "value": "'$ROLLBACK_TARGET'"}]'

        # Send alert
        curl -X POST -H 'Content-type: application/json' \
          --data '{"text":"üö® Production deployment failed, rollback initiated"}' \
          ${{ secrets.SLACK_WEBHOOK_URL }}

  notify:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production, rollback]
    if: always()
    steps:
    - name: Send deployment notification
      run: |
        if [ "${{ needs.deploy-production.result }}" = "success" ]; then
          STATUS="‚úÖ Production deployment successful"
          COLOR="good"
        elif [ "${{ needs.rollback.result }}" = "success" ]; then
          STATUS="‚ö†Ô∏è Production deployment failed, rollback completed"
          COLOR="warning"
        else
          STATUS="‚ùå Deployment failed"
          COLOR="danger"
        fi

        curl -X POST -H 'Content-type: application/json' \
          --data '{"attachments": [{"color": "'$COLOR'", "text": "'$STATUS' - Commit: ${{ github.sha }}"}]}' \
          ${{ secrets.SLACK_WEBHOOK_URL }}